# Bitácora de aprendizajes por cada checkpoint 

## Checkpoint 1

En el primer checkpoint nos fuimos familiarizando con los objetivos a cumplir en el trabajo práctico, las historias de usuario obligatorias y opcionales. Se decidió codear la parte del backend con node, python y go. Por otro lado, el frontend web fue codeado con react y typescript mientras que el frontend mobile fue codeado con react native y typescript, utilizando la libreria native base para algunos componentes. 

## Checkpoint 2

En el segundo checkpoint tomamos como aprendrizaje el uso de queues para métricas con go y redis. 
Por otro lado, desarrollamos una Fast API con un middleware. Además se configuro un docker compose exclusivo para tests. 

## Checkpoint 3

En el tercer checkpoint aprendimos a utilizar firebase storage con middleware y con distintos protocolos para reconocer archivos. También en épocas de parciales y entregas finales empezamos a conocer nuestros límites, teniendo en cuenta puntos que nos propusimos hacer y los que pudimos hacer. 
Por otro lado, desde el lado frontend, comenzamos a tener mayor conocimiento sobre distintos componentes y librerias para mejorar más la visual de la aplicación. 

## Entrega final 

En la entrega final aprendimos sobre los pros y contras prácticos entre sql y mongoDB para utilizar las bases de datos. Por otro lado, se desarrollaron las notificaciones y como un aprendizaje particularmente en este tema que nos llevamos que en un emulador desde android studio no se pueden probar las notificaciones, mientras que probándolo desde un celular físico funciona perfectamente. 

## Con el diario del Lunes... que podríamos haber hecho?

Teniendo en cuenta el resultado del trabajo práctico final, reconocemos que, desde el lado del backend, podríamos haber no usado okteto ya que no anda bien, tiene documentación desactualizada y las cosas se caen de la nada. Además, podríamos haber usado NoSQL MongoDB no solo para las métricas sino para otras cosas también. 
Desde el lado del frontend, si usaramos nuevamente react native, no usuariamos la libreria native base ya que hay código ejemplo dentro de la documentación que no funciona y no hay documentación extra que lo solucione. De igual manera, si tuvieramos que elegir un lenguaje para desarrollar el frontend, en vez de react native hubieramos usado flutter. 
